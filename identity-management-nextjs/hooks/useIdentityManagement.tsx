"use client";

import { ethers } from "ethers";
import { RefObject, useCallback, useEffect, useMemo, useRef, useState } from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// Import ABI and address mappings for the IdentityManagement smart contract
// These files are generated by a script parsing deployment artifacts
import { IdentityManagementAddresses } from "@/abi/IdentityManagementAddresses";
import { IdentityManagementABI } from "@/abi/IdentityManagementABI";

// Define type for clear values used in contract interactions
export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

// Define type for IdentityManagement contract metadata
type IdentityManagementInfoType = {
  abi: typeof IdentityManagementABI.abi; // Contract ABI
  address?: `0x${string}`; // Contract address (optional)
  chainId?: number; // Chain ID (optional)
  chainName?: string; // Chain name (optional)
};

/**
 * Resolves IdentityManagement contract metadata for the given EVM chainId.
 *
 * Retrieves contract ABI and address from generated mappings. If chainId is not provided or not found,
 * returns only the ABI. Otherwise, includes address, chainId, and chainName if available.
 *
 * @param chainId - Target chain ID (e.g., 1 for Ethereum Mainnet, 5 for Goerli). Undefined returns ABI only.
 * @returns Object containing contract ABI and optional address, chainId, and chainName.
 */
function getIdentityManagementByChainId(chainId: number | undefined): IdentityManagementInfoType {
  if (!chainId) {
    // Return ABI only if no chainId is provided
    return { abi: IdentityManagementABI.abi };
  }

  const entry = IdentityManagementAddresses[chainId];

  if (!entry || !entry.address || entry.address === ethers.ZeroAddress) {
    // Return ABI and chainId if no valid address is found
    return { abi: IdentityManagementABI.abi, chainId };
  }

  // Return full contract info if address is valid
  return {
    address: entry.address as `0x${string}` | undefined,
    chainId: entry.chainId ?? chainId,
    chainName: entry.chainName,
    abi: IdentityManagementABI.abi,
  };
}

/**
 * Main React hook for interacting with the IdentityManagement smart contract.
 * Provides functions to register an identity, prove age-related claims, and check registration status.
 *
 * @param parameters - Object containing dependencies like FhevmInstance, provider, signer, and chain checks.
 * @returns Object with contract interaction functions, states, and status flags.
 */
export const useIdentityManagement = (parameters: {
  instance: FhevmInstance | undefined; // FHEVM instance for encryption
  fhevmDecryptionSignatureStorage: GenericStringStorage; // Storage for decryption signatures
  eip1193Provider: ethers.Eip1193Provider | undefined; // EIP-1193 compliant provider
  chainId: number | undefined; // Current chain ID
  ethersSigner: ethers.JsonRpcSigner | undefined; // Signer for sending transactions
  ethersReadonlyProvider: ethers.ContractRunner | undefined; // Read-only provider for contract calls
  sameChain: RefObject<(chainId: number | undefined) => boolean>; // Function to check chain consistency
  sameSigner: RefObject<(ethersSigner: ethers.JsonRpcSigner | undefined) => boolean>; // Function to check signer consistency
}) => {
  const { instance, chainId, ethersSigner, ethersReadonlyProvider, sameChain, sameSigner } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  // State to track if the user is registered with the contract
  const [isRegistered, setIsRegistered] = useState<boolean>(false);
  // State to store request ID for age over 18 proof
  const [requestIdOver18, setRequestIdOver18] = useState<bigint | undefined>(undefined);
  // State to store request ID for age over 21 and valid country proof
  const [requestIdOver21, setRequestIdOver21] = useState<bigint | undefined>(undefined);
  // State to store proof results from ProofResult events
  const [proofResults, setProofResults] = useState<Map<bigint, boolean>>(new Map());
  // State to track if registration status is being refreshed
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  // State to track if identity registration is in progress
  const [isRegistering, setIsRegistering] = useState<boolean>(false);
  // State to track if proof submission is in progress
  const [isProving, setIsProving] = useState<boolean>(false);
  // State to store status messages for UI feedback
  const [message, setMessage] = useState<string>("");
  // State to store the registered age for pre-checking proof eligibility
  const [registeredAge, setRegisteredAge] = useState<number | undefined>(undefined);
  // State to store proof validity results
  const [isProofValid, setIsProofValid] = useState<{ over18: boolean | null; over21AndValidCountry: boolean | null }>({
    over18: null,
    over21AndValidCountry: null,
  });

  // Ref to store current IdentityManagement contract info
  const identityManagementRef = useRef<IdentityManagementInfoType | undefined>(undefined);
  // Ref to track refreshing status to avoid race conditions
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  // Ref to track registration status to avoid race conditions
  const isRegisteringRef = useRef<boolean>(isRegistering);
  // Ref to track proving status to avoid race conditions
  const isProvingRef = useRef<boolean>(isProving);

  //////////////////////////////////////////////////////////////////////////////
  // IdentityManagement
  //////////////////////////////////////////////////////////////////////////////

  // Memoized contract metadata based on chainId
  const identityManagement = useMemo(() => {
    // Get contract info for the current chainId
    const c = getIdentityManagementByChainId(chainId);
    // Store contract info in ref for use in async operations
    identityManagementRef.current = c;

    // Set error message if no contract address is found
    if (!c.address) {
      setMessage(`IdentityManagement deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Registration Status
  //////////////////////////////////////////////////////////////////////////////

  // Memoized flag indicating if the contract is deployed
  const isDeployed = useMemo(() => {
    if (!identityManagement) {
      return undefined;
    }
    // Check if contract address exists and is not zero
    return Boolean(identityManagement.address) && identityManagement.address !== ethers.ZeroAddress;
  }, [identityManagement]);

  // Memoized flag indicating if registration status can be checked
  const canGetRegistration = useMemo(() => {
    return identityManagement.address && ethersReadonlyProvider;
  }, [identityManagement.address, ethersReadonlyProvider]);

  // Function to refresh the registration status of the current signer
  const refreshRegistrationStatus = useCallback(() => {
    console.log("[useIdentityManagement] call refreshRegistrationStatus()");
    // Skip if already refreshing
    if (isRefreshingRef.current) {
      return;
    }

    // Check if required dependencies are available
    if (
      !identityManagementRef.current ||
      !identityManagementRef.current?.chainId ||
      !identityManagementRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setIsRegistered(false);
      return;
    }

    // Set refreshing state
    isRefreshingRef.current = true;
    setIsRefreshing(true);

    // Store current contract info for consistency checks
    const thisChainId = identityManagementRef.current.chainId;
    const thisIdentityManagementAddress = identityManagementRef.current.address;

    // Create contract instance for read-only calls
    const thisIdentityManagementContract = new ethers.Contract(
      thisIdentityManagementAddress,
      identityManagementRef.current.abi,
      ethersReadonlyProvider,
    );

    // Check if the signer's address is registered
    thisIdentityManagementContract
      .isIdentityRegistered(ethersSigner?.address ?? ethers.ZeroAddress)
      .then((value) => {
        console.log("[useIdentityManagement] isIdentityRegistered()=" + value);
        // Update state only if chain and contract address are still valid
        if (
          sameChain.current(thisChainId) &&
          thisIdentityManagementAddress === identityManagementRef.current?.address
        ) {
          setIsRegistered(value);
        }
      })
      .catch((error) => {
        console.error("[useIdentityManagement] Error in isIdentityRegistered:", error);
        setMessage("Failed to refresh registration status.");
      })
      .finally(() => {
        // Reset refreshing state
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain, identityManagementRef]);

  // Automatically refresh registration status when dependencies change
  useEffect(() => {
    if (canGetRegistration && !isRefreshingRef.current) {
      refreshRegistrationStatus();
    }
  }, [canGetRegistration, refreshRegistrationStatus]);

  // Event listener for ProofResult to update proof validity
  useEffect(() => {
    if (ethersReadonlyProvider && identityManagement.address && identityManagement.abi) {
      const contract = new ethers.Contract(identityManagement.address, identityManagement.abi, ethersReadonlyProvider);

      const listener = (user: string, requestId: bigint, proofType: string, result: boolean) => {
        console.log(
          `[useIdentityManagement] ProofResult event: requestId=${requestId}, proofType=${proofType}, result=${result}`,
        );

        setProofResults((prev) => {
          const newMap = new Map(prev);
          newMap.set(requestId, result);
          return newMap;
        });

        if (proofType === "AgeOver18") {
          setIsProofValid((prev) => ({ ...prev, over18: result }));
          setMessage(result ? "You are over 18" : "You are not over 18");
        } else if (proofType === "AgeOver21AndValidCountry") {
          setIsProofValid((prev) => ({ ...prev, over21AndValidCountry: result }));
          setMessage(
            result ? "You are over 21 and from a valid country" : "You are not over 21 or from an invalid country",
          );
        }
      };

      contract.on("ProofResult", listener);

      return () => {
        contract.off("ProofResult", listener);
      };
    }
  }, [ethersReadonlyProvider, identityManagement.address, identityManagement.abi]);

  //////////////////////////////////////////////////////////////////////////////
  // Register Identity
  //////////////////////////////////////////////////////////////////////////////

  // Memoized flag indicating if identity registration is possible
  const canRegister = useMemo(() => {
    return identityManagement.address && instance && ethersSigner && !isRegistered && !isRefreshing && !isRegistering;
  }, [identityManagement.address, instance, ethersSigner, isRegistered, isRefreshing, isRegistering]);

  // Function to register an identity with encrypted inputs
  const registerIdentity = useCallback(
    async (age: number, isStudent: boolean, passportHash: bigint, city: number, countryCode: number) => {
      // Skip if refreshing or registering
      if (isRefreshingRef.current || isRegisteringRef.current || !ethersSigner) {
        return;
      }

      // Check if contract address and FHEVM instance are available
      if (!identityManagement.address || !instance) {
        return;
      }

      // Store age for pre-checking proof eligibility
      setRegisteredAge(age);

      // Store current context for consistency checks
      const thisChainId = chainId;
      const thisIdentityManagementAddress = identityManagement.address;
      const thisEthersSigner = ethersSigner;
      const thisIdentityManagementContract = new ethers.Contract(
        thisIdentityManagementAddress,
        identityManagement.abi,
        thisEthersSigner,
      );

      // Set registering state
      isRegisteringRef.current = true;
      setIsRegistering(true);
      setMessage("Start registering identity...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        // Check if context is still valid
        const isStale = () =>
          thisIdentityManagementAddress !== identityManagementRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const signerAddress = await thisEthersSigner.getAddress();

          // Encrypt age
          const inputAge = instance.createEncryptedInput(thisIdentityManagementAddress, signerAddress);
          inputAge.add8(age);
          const encAge = await inputAge.encrypt();
          const encryptedAge = encAge.handles[0];
          const ageProof = encAge.inputProof;

          // Encrypt isStudent
          const inputStudent = instance.createEncryptedInput(thisIdentityManagementAddress, signerAddress);
          inputStudent.addBool(isStudent);
          const encStudent = await inputStudent.encrypt();
          const encryptedIsStudent = encStudent.handles[0];
          const studentProof = encStudent.inputProof;

          // Encrypt passportHash
          const inputPassport = instance.createEncryptedInput(thisIdentityManagementAddress, signerAddress);
          inputPassport.add256(passportHash);
          const encPassport = await inputPassport.encrypt();
          const encryptedPassportHash = encPassport.handles[0];
          const passportProof = encPassport.inputProof;

          // Encrypt city
          const inputCity = instance.createEncryptedInput(thisIdentityManagementAddress, signerAddress);
          inputCity.add16(city);
          const encCity = await inputCity.encrypt();
          const encryptedCity = encCity.handles[0];
          const cityProof = encCity.inputProof;

          // Encrypt countryCode
          const inputCountry = instance.createEncryptedInput(thisIdentityManagementAddress, signerAddress);
          inputCountry.add8(countryCode);
          const encCountry = await inputCountry.encrypt();
          const encryptedCountryCode = encCountry.handles[0];
          const countryCodeProof = encCountry.inputProof;

          // Skip if context is stale
          if (isStale()) {
            setMessage("Ignore register identity");
            return;
          }

          setMessage("Call registerIdentity...");

          // Call the contract's registerIdentity function with encrypted inputs
          const tx: ethers.TransactionResponse = await thisIdentityManagementContract.registerIdentity(
            encryptedAge,
            ageProof,
            encryptedIsStudent,
            studentProof,
            encryptedPassportHash,
            passportProof,
            encryptedCity,
            cityProof,
            encryptedCountryCode,
            countryCodeProof,
          );

          setMessage(`Wait for tx:${tx.hash}...`);

          // Wait for transaction confirmation
          const receipt = await tx.wait();
          if (!receipt) {
            setMessage("Transaction failed or not mined.");
            return;
          }

          setMessage(`Register identity completed status=${receipt.status}`);

          // Skip if context is stale
          if (isStale()) {
            setMessage("Ignore register identity");
            return;
          }

          // Refresh registration status after successful transaction
          refreshRegistrationStatus();
        } catch (error) {
          console.error(error);
          setMessage("Register identity Failed!");
        } finally {
          // Reset registering state
          isRegisteringRef.current = false;
          setIsRegistering(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      identityManagement.address,
      identityManagement.abi,
      instance,
      chainId,
      refreshRegistrationStatus,
      sameChain,
      sameSigner,
    ],
  );

  //////////////////////////////////////////////////////////////////////////////
  // Prove Functions
  //////////////////////////////////////////////////////////////////////////////

  // Memoized flag indicating if proof submission is possible
  const canProve = useMemo(() => {
    return identityManagement.address && ethersSigner && isRegistered && !isRefreshing && !isProving;
  }, [identityManagement.address, ethersSigner, isRegistered, isRefreshing, isProving]);

  // Function to prove the user is over 18
  const proveAgeOver18 = useCallback(async () => {
    // Skip if refreshing or proving
    if (isRefreshingRef.current || isProvingRef.current || !ethersSigner) {
      return;
    }

    // Check if contract address is available
    if (!identityManagement.address) {
      return;
    }

    // Check registered age to avoid unnecessary contract calls
    if (registeredAge !== undefined && registeredAge <= 18) {
      setMessage("You are not over 18, no need to call contract.");
      setIsProofValid((prev) => ({ ...prev, over18: false }));
      return;
    }

    // Store current context for consistency checks
    const thisChainId = chainId;
    const thisIdentityManagementAddress = identityManagement.address;
    const thisEthersSigner = ethersSigner;
    const thisIdentityManagementContract = new ethers.Contract(
      thisIdentityManagementAddress,
      identityManagement.abi,
      thisEthersSigner,
    );

    // Set proving state
    isProvingRef.current = true;
    setIsProving(true);
    setMessage("Start proveAgeOver18...");

    const run = async () => {
      // Check if context is still valid
      const isStale = () =>
        thisIdentityManagementAddress !== identityManagementRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        setMessage("Call proveAgeOver18...");

        // Call the contract's proveAgeOver18 function
        const tx: ethers.TransactionResponse = await thisIdentityManagementContract.proveAgeOver18();

        setMessage(`Wait for tx:${tx.hash}...`);

        // Wait for transaction confirmation
        const receipt = await tx.wait();
        if (!receipt) {
          setMessage("Transaction failed or not mined.");
          return;
        }

        // Create interface for parsing logs
        const iface = new ethers.Interface(identityManagement.abi);

        // Calculate event topic hash for ProofRequested event
        const eventSignature = "ProofRequested(address,uint256,string)";
        const eventTopic = ethers.id(eventSignature);

        // Find the ProofRequested event log
        const log = receipt.logs.find((l) => l.topics[0] === eventTopic);

        if (!log) {
          setMessage("No ProofRequested log found in transaction receipt.");
          console.log("Available logs:", receipt.logs);
          return;
        }

        console.log("Found log:", log);

        // Parse the event log
        const parsedLog = iface.parseLog(log);
        console.log("Parsed log:", parsedLog);

        if (!parsedLog) {
          setMessage("Failed to parse log. Check ABI or log data.");
          console.log("Log data:", log.data, "Topics:", log.topics);
          return;
        }

        // Extract requestId from the event
        const requestId = parsedLog.args.requestId as bigint;

        setMessage(`ProveAgeOver18 completed status=${receipt.status}, requestId=${requestId}`);

        // Skip if context is stale
        if (isStale()) {
          setMessage("Ignore proveAgeOver18");
          return;
        }

        // Store requestId
        setRequestIdOver18(requestId);
      } catch (error) {
        console.error("Error in proveAgeOver18:", error);
        setMessage("ProveAgeOver18 Failed!");
      } finally {
        // Reset proving state
        isProvingRef.current = false;
        setIsProving(false);
      }
    };

    run();
  }, [ethersSigner, identityManagement.address, identityManagement.abi, chainId, sameChain, sameSigner, registeredAge]);

  // Function to prove the user is over 21 and has a valid country code
  const proveAgeOver21AndValidCountry = useCallback(async () => {
    // Skip if refreshing or proving
    if (isRefreshingRef.current || isProvingRef.current || !ethersSigner) {
      return;
    }

    // Check if contract address is available
    if (!identityManagement.address) {
      return;
    }

    // Check registered age to avoid unnecessary contract calls
    if (registeredAge !== undefined && registeredAge <= 21) {
      setMessage("You are not over 21, no need to call contract.");
      setIsProofValid((prev) => ({ ...prev, over21AndValidCountry: false }));
      return;
    }

    // Store current context for consistency checks
    const thisChainId = chainId;
    const thisIdentityManagementAddress = identityManagement.address;
    const thisEthersSigner = ethersSigner;
    const thisIdentityManagementContract = new ethers.Contract(
      thisIdentityManagementAddress,
      identityManagement.abi,
      thisEthersSigner,
    );

    // Set proving state
    isProvingRef.current = true;
    setIsProving(true);
    setMessage("Start proveAgeOver21AndValidCountry...");

    const run = async () => {
      // Check if context is still valid
      const isStale = () =>
        thisIdentityManagementAddress !== identityManagementRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        setMessage("Call proveAgeOver21AndValidCountry...");

        // Call the contract's proveAgeOver21AndValidCountry function
        const tx: ethers.TransactionResponse = await thisIdentityManagementContract.proveAgeOver21AndValidCountry();

        setMessage(`Wait for tx:${tx.hash}...`);

        // Wait for transaction confirmation
        const receipt = await tx.wait();
        if (!receipt) {
          setMessage("Transaction failed or not mined.");
          return;
        }

        // Create interface for parsing logs
        const iface = new ethers.Interface(identityManagement.abi);

        // Calculate event topic hash for ProofRequested event
        const eventSignature = "ProofRequested(address,uint256,string)";
        const eventTopic = ethers.id(eventSignature);

        // Find the ProofRequested event log
        const log = receipt.logs.find((l) => l.topics[0] === eventTopic);

        if (!log) {
          setMessage("No ProofRequested log found in transaction receipt.");
          console.log("Available logs:", receipt.logs);
          return;
        }

        console.log("Found log:", log);

        // Parse the event log
        const parsedLog = iface.parseLog(log);
        console.log("Parsed log:", parsedLog);

        if (!parsedLog) {
          setMessage("Failed to parse log. Check ABI or log data.");
          console.log("Log data:", log.data, "Topics:", log.topics);
          return;
        }

        // Extract requestId from the event
        const requestId = parsedLog.args.requestId as bigint;

        setMessage(`ProveAgeOver21AndValidCountry completed status=${receipt.status}, requestId=${requestId}`);

        // Skip if context is stale
        if (isStale()) {
          setMessage("Ignore proveAgeOver21AndValidCountry");
          return;
        }

        // Store requestId
        setRequestIdOver21(requestId);
      } catch (error) {
        console.error("Error in proveAgeOver21AndValidCountry:", error);
        setMessage("ProveAgeOver21AndValidCountry Failed!");
      } finally {
        // Reset proving state
        isProvingRef.current = false;
        setIsProving(false);
      }
    };

    run();
  }, [ethersSigner, identityManagement.address, identityManagement.abi, chainId, sameChain, sameSigner, registeredAge]);

  // Return all functions, states, and status flags for use in the component
  return {
    contractAddress: identityManagement.address,
    canRegister,
    canProve,
    canGetRegistration,
    registerIdentity,
    proveAgeOver18,
    proveAgeOver21AndValidCountry,
    refreshRegistrationStatus,
    isRegistered,
    requestIdOver18,
    requestIdOver21,
    proofResults,
    message,
    isRegistering,
    isProving,
    isRefreshing,
    isDeployed,
    isProofValid,
    registeredAge,
  };
};
